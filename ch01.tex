\blogchapter{chap:PythonPrimer}{Python Primer}

I doubted doing the exercises for the first chapter for like an hour while I walked to my home from work. Hell, I even doubted doing the whole book, Data Structures? But even though I know most of the theory, I can't extract it like its hot. The other day I was implementing a solution to a VERY simple problem and I had trouble recalling the data structure with constant time complexity removal (answer: linked list). After that I felt extremely bad for myself, if I can't use data structures as if they were cards in a poker match then I am not really a Software Developer. My job is to juggle multiple solutions to craft one that is at least perfect.

\blogsection{sec:reshaping}{Reshaping the future}{}{} \label{sec:reshaping}

It feels like I've been doing it wrong during the last years, I've been focusing on developing a complete top notch quality solution, worrying about code quality, unit testing, commenting my code, learning back end and front end, and learning to make my own architectures, hell, my last subject was starting to learn QT.

It ends now, I am focusing full force on Computer Science, and just a tiny bit of time learning new technologies. It is amazing what I am seeing everywhere, Angular JS, Node, MVVM on WPF, QML, it is just fantastic. But trying to cover everything is exhausting, I feel like I am getting nowhere. I need to up the ante, and I feel the only way is to have the most solid foundation, which is Computer Science, plain and simple.

\blogsubsection{ssec:Exercises}{Exercises}{}{}
\label{ssec:Exercises}

So it took me some strength to accept and do this chapter no matter what, but now that I have started... it is fun. Feels good being good at something. 

\blogsubsubsection{sssec:ex1_1}{R-1.1}{chap:PythonPrimer}{} \label{sssec:ex1_1}


Write a short Python function, \texttt{is_multiple(n, m)}, that takes two integer values and returns \texttt{True} if $n$ is a multiple of $m$, that is, $n = mi$ for some integer $i$, and \texttt{False} otherwise.

\begin{lstlisting}[label=ex1.1,caption=Exercise R-1.1,language=Python]
def is_multiple(n, m):
    return True if (n % m == 0) else False
\end{lstlisting}

\blogsubsubsection{sssec:ex1_2}{R-1.2}{chap:PythonPrimer}{} \label{sssec:ex1_2}

Write a short Python function, \texttt{is_even(k)}, that takes an integer value and returns \texttt{True} if $k$ is even, and \texttt{False} otherwise. However, your function cannot use the multiplication, modulo, or division operators

\begin{lstlisting}[label=ex1.2,caption=Exercise R-1.2,language=Python]
def is_even(k):
    return (k & 1 == 0)
\end{lstlisting}

\blogsubsubsection{sssec:ex1_3}{R-1.3}{chap:PythonPrimer}{} \label{sssec:ex1_3}

Write a short Python function, \texttt{minmax(data)}, that takes a sequence of one or more numbers, and returns the smallest and largest numbers, in the form of a tuple of length two. Do not use the built-in functions \texttt{min} or \texttt{max} in implementing your solution.

\begin{lstlisting}[label=ex1.3,caption=Exercise R-1.3, language=Python]
class MinMax():
    def __init__(self, field1, field2):
        self.min = field1
        self.max = field2
    def __str__(self):
        return "Min {min} - Max {max}".format(min=str(self.min), max=str(self.max))

def minmax(data):
    start = 0
    mm = MinMax(data[start],data[start])
    if len(data) & 1  == 1:
        if data[start] < data[start+1]:
            mm.max = data[start+1]
            mm.min = data[start]
            start += 2
        else:
            start += 1
    for index in range(start, len(data[start:]), 2):
        if data[index] < data[index+1] :
            l_min = data[index]
            l_max = data[index+1]
        else:
            l_min = data[index+1]
            l_max = data[index]
        if mm.min > l_min:
            mm.min = l_min
        if mm.max < l_max:
            mm.max = l_max
    return mm
\end{lstlisting}